#-----------------------------------------------------------------------
2016-12-02:|
-------------

Status: code compiles and runs but __nothing working__,
newton steps are not descent directions, hessians of convex test functions
often not positive semidefinite.

Improve diagnostics in
           TestUnconstrainedMinimization::testList
print value of known global min, value at solution.

Test the backsolve routine. The forwardsolve routine is already tested.

Implement
             MathUtils.solveWithPreconditioning
for a positive semidefinite system.


#-----------------------------------------------------------------------
2016-12-05:|
-------------

Add new Exception LinSolveException when solving Ax=b fails. Should contain
message as well as the matrix A, the vector b instead of adding these as strings
to the message.

Add class Constraint (inequality constraint), has id, gradient, hessian, method to check
if it is satisfied, strictly satisfied with margin of error etc.

Introduce class MinimizationProblem:
has objective function with gradient and hessian and constraints as well as a method
allocating a solver.

Rename the current TestFunctions to MinimizationProblems.

Then do the BarrierSolver.

#-----------------------------------------------------------------------
2016-12-06:|
-------------

Find out why the Type1 power test functions produce no output in the test.
Complete the BarrierSolver: factory functions for versions with and without equality constraints.


#-----------------------------------------------------------------------
2016-12-11:|
-------------

Implement the affine changed power function minmization problems, factory function
OptimizationProblems.randomPowerProblem,
See docs/cvx_notes.pdf, p5, Example 2.1, where all $phi_j(x) = (x*x)^q$ with q>1 to ensure
twice continuous differentiability.


#--------------------------------------------------------------
2016-12-16:|
-------------

Implement the constrained test problems.

New optimization problem
                     OptimizationProblems.minX1
with constraints fails the test: backtracking line search does not reach sufficient decrease
after 100 iterations (in UnconstrainedSolver::solve). This is only explicable if the objective function
or the gradient are messed up.

Next: implement KKT system solver with block elimination in MatrixUtils.

#--------------------------------------------------------------
2017-01-14:|
-------------

Implement quadratically constrained quadratic problems (faster setup), then add many test
problems with known solutions.


#--------------------------------------------------------------
2017-01-14A:|
--------------

The class ConstraintSet also needs a method doSOIAnalysis which takes a set of
equality constraints, low priority. We need some tests for SOI feasibility analysis.

Simplify the various forms of the BarrierSolver.apply constructors by adding an optional feasible
point to the ConstraintSets and a method to add a feasible point.
The barrier solvers should now no longer assume that a feasible point is given. Instead check if
the inequality constraint set has one and if it is in the range of the equality constraints.
Otherwise it needs to perform a feasibility analysis to find one.
We need to beef up the simple feasibility analysis to be able to deal with equality constraints.

The simplest way may be to operate on the level of the objective function and inequality constraints
(by restricting these to the range of the equality constraints) and not on the level of the barrier solver.
However this is very inefficient since it implies many more matrix multiplications.

The matrices are bigger (more columns) the fewer equality conditions we have -- a bad constellation.

Consequently it might better to have two versions of simple feasibility analysis: one with
and one without equality constraints. The feasibility solver with equality constraints
needs separate implementation as only the variable x in the compound variable (x,s) is affected
by the transformation x=Fu.
Thus the matrix which transforms the barrier function has two blocks the second of which is the
identity matrix. Needless to say this multiplication can be implemented more efficiently by operating on
the blocks separately (and doing nothing on the block indexed by the s-variables).


#--------------------------------------------------------------
2017-01-23:|
--------------

Find out what the problem is with the accuracy of the solutions of the KKT system.
There is no problem with MatrixUtils.triangularSolve, the errors in the test cases
with the identical matrices H=LL' are zero.

Even though identical matrices L and  H=LL' are used in the test for MatrixUtils.triangularSolve
and the KKTSystem solution, the condition numbers are worse in the KKT case (1600 versus 500).
The equilibration of H in the KKTSystem solver seems to increase the condition number.
But it is still too small to cause such inaccuracy.
Thus there must be some other problem with the KKT code.

#--------------------------------------------------------------
2017-01-23:|
--------------

KKTSystem.solvePD:
when Ruiz equilibration is switched off (i.e. unmodified blockSolve is used) works
flawlessly with condition numbers of H as large as 2e6.
Ruiz equilibration cuts the condition numbers in half but then the accuracy of the
solution goes down badly.
There must therefore be a BUG in the transformation to and from the equilibrated system.

BUG is fixed, status: working!


#--------------------------------------------------------------
2017-02-04:|
--------------

The OptimizationProblem should get a list of (inequality) Constraints as well as an
optional EqualityConstraints object which then determine which BarrierSolver is used.



####################################################################################################
Design break:|
###############


https://github.com/spyqqqdia/cvx


Approach is wrong:

_OptimizationProblem_

has a solver as basic ingredient,
should be the other way around:
OptimizationProblem has objective function and ConstraintSet
and then computes solvers for the problem


_ConstraintSet_:

Allocates the phase_I and phase_I_SOI optimization problems,
then solves these and returns a feasibility report.

To do this the ConstraintSet has methods to turn itself
(return) the ConstraintSet for the phase_I and phase_I_SOI
optimization problems.


_Solvers (BarroerSolver)_:

With this each Solver can assume that it has a feasible point
and does not have to concern itself with feasibility analysis.


#----------------------------------------------------
Using self type annotation:|
-----------------------------

generally take some of the static functions out of the companion objects
and into the corresponding classes


_Constraint_:
the methods to turn the Constraint into its phase_I form.
Move the method to turn a constraint into tis phase_I_SOI form into the class
ConstraintSet, since we need the full context of the constraint set to do this
(number of all constraints and index of particular constraint).




#-------------------------------------------------------------------------------------------
2017-10-09:|
-------------

First: Clean up ConstraintSet.scala
Clean up the tests to conform to the new signatures.

Modify FeasibilityReport to include ||Ax-b|| in case of equality constraints.

Write tests cases based on Kullback-Leibler distane minimization with known solution
(because of symmetry) or known infeasibility (because of probabilistic inequalities).



#-------------------------------------------------------------------------------------------
2017-10-10:|
-------------

Do we have to do something special if the set of inequality constraints is empty?

Add on expectation, moment and probability inequality constraints to the
Constraints object.



#----------------------------------------------------------------------------------------
2017-10-11:|
-------------

Implement feasible dist_KL problems with known analytic solutions
and some which are known to be infeasible.


#----------------------------------------------------------------------------------------
2017-10-12:|
-------------

ConstraintSet.phase_I_Analysis:

(A) The phase I problem can lead to a singular KKT system under reasonable conditions.
To see this consider a case where the side conditions are linear (hence Hessian zero)
and do not depend on some of the variables.
The Hessian of the barrier function (cvx.pdf, p40 (44)) then has zero rows.

Currently this leads to an exception in
    MatrixUtils$.ruizEquilibrate(MatrixUtils.scala:152)
	at MatrixUtils$.solveWithPreconditioning(MatrixUtils.scala:190)

as the preconditioner does not tolerate a zero row in the Hessian H
(if there are no equality conditions).

If there are no equality conditions then a zero row in the Hessian H
leads to a singular system which has zeros on the right hand side, so that it
is still solvable, but we have not implemented a solution for such a system.

The code in MatrixUtils$.solveWithPreconditioning needs to be adapted to cope
with this case also.

The problem occurs for example with the test problem
OptimizationProblems.kl_1 if we remove the probability conditions
x_j>0 and sum_jx_j=1 from the list of conditions.

(B) The barrier solver for the phase I problem does not deal with the
equality constraints correctly:
   dimension mismatch, e.g. in OptimizationProblems.kl_1
What should we do with these?
We could disregard them in phase I and return a feasible point satisfying
only the inequality constraints, then hope that a full Newton step
is taken in the solution of the original KKT system (which implies that the
equality constraints are satisfied automatically).


#----------------------------------------------------------------------------------------
2017-10-16:|
-------------

__EqualityConstraint:

implement the function ::phase_I_SOI_EqualityConstraint: EqualityConstraint

__OptimizationProblems.kl_1:
work out the solution for general n, heuristic is that the probability condition
on the big set (j>=n/2) must be hit with equality.


#----------------------------------------------------------------------------------------
2017-10-17:|
-------------

__EqualityConstraint:
implement the function ::phase_I_SOI_EqualityConstraint: EqualityConstraint

Implement bigger, randomly generated KL_problems to see how fast/slow we are
with the KKT system solution without native libraries.

!!__OptimizationProblems.kl_2
Figure out why this leads to a singular KKT system in the phase I analysis.
The hessian H of the barrier function in KKTSystem::blockSolve really is singular!
See also Log.txt.

Note: this system has only the positivity constraints x_j>0 as inequalities.
In phase I analysis the j-th constraint each of depends on the j-th variable
and the new variable s (the last variable) only. Thus the hessian of the constraint
is nonzero only on the diagonal and the last row and column.

The objective function only depends on the variable s, so the hessian has only
one nonzero entry (last diagonal element). Consequently the hessian of the barrier
function has the same structure as that of the constraints. This is indeed what we
see in the log file BUT this matrix is singular
(subtract all other rows from the last one).

It is hard to believe that the constraints x_j>0 lead to a singular hessian
for the barrier function. BUG suspected.


#----------------------------------------------------------------------------------------
2017-10-18:|
-------------

Figure out why the phase I analysis for the OptimizationProblems.kl_1
and OptimizationProblems.kl_3 run into a singular KKT system.

__BUG___ detected: Ruiz equilibration leads from a positive definite matrix H
to one which has a slightly negative eigenvalue!!!!
Then the corresponding KKTSystem is flagged as singular, see
Logs/ConstraintSet_phase_I_log.txt


#----------------------------------------------------------------------------------------
2017-11-01:|
-------------

KKTSystem.solve:
tries the block elimination with Cholesky factorization. If this fails
regularizes the system with the trick in Boyd. This will fail if the system is
singular. In this case we go to SVD. Check that all this is proper, i.e. no
regularization which distorts the system too much so solutions are no longer
Newton steps in a _descent direction_.
This could happen if we were to use simple regularization by adding eps*I
to the singular (but positive semidefinite) Hessian H.

Is likely correct.

_tolerances_:

Currently we have only one tolerance parameter to handle all tolerances:
for constraints
for the duality gap (termination criterion in barrier solver)
for norm of gradient (as termination criterion in case of interior point solution).

It may be useful to distinguish between these tolerance since in particular the
tolerance for the duality gap often has to be reduced to avoid running into a
singular KKT system.


----------------------------------------------------------------------------------------
2017-11-02:|
-------------

SOI analysis does not work (IndexOutOfBounds on DenseVector).
Run the feasibility tests in Runner.

 
 





