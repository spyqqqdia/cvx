#-----------------------------------------------------------------------
2016-12-02:|
-------------

Status: code compiles and runs but __nothing working__,
newton steps are not descent directions, hessians of convex test functions
often not positive semidefinite.

Improve diagnostics in
           TestUnconstrainedMinimization::testList
print value of known global min, value at solution.

Test the backsolve routine. The forwardsolve routine is already tested.

Implement
             MathUtils.solveWithPreconditioning
for a positive semidefinite system.


#-----------------------------------------------------------------------
2016-12-05:|
-------------

Add new Exception LinSolveException when solving Ax=b fails. Should contain
message as well as the matrix A, the vector b instead of adding these as strings
to the message.

Add class Constraint (inequality constraint), has id, gradient, hessian, method to check
if it is satisfied, strictly satisfied with margin of error etc.

Introduce class MinimizationProblem:
has objective function with gradient and hessian and constraints as well as a method
allocating a solver.

Rename the current TestFunctions to MinimizationProblems.

Then do the BarrierSolver.

#-----------------------------------------------------------------------
2016-12-06:|
-------------

Find out why the Type1 power test functions produce no output in the test.
Complete the BarrierSolver: factory functions for versions with and without equality constraints.


#-----------------------------------------------------------------------
2016-12-11:|
-------------

Implement the affine changed power function minmization problems, factory function
OptimizationProblems.randomPowerProblem,
See docs/cvx_notes.pdf, p5, Example 2.1, where all $phi_j(x) = (x*x)^q$ with q>1 to ensure
twice continuous differentiability.


#--------------------------------------------------------------
2016-12-16:|
-------------

Implement the constrained test problems.

New optimization problem
                     OptimizationProblems.minX1
with constraints fails the test: backtracking line search does not reach sufficient decrease
after 100 iterations (in UnconstrainedSolver::solve). This is only explicable if the objective function
or the gradient are messed up.

Next: implement KKT system solver with block elimination in MatrixUtils.

#--------------------------------------------------------------
2017-01-14:|
-------------

Implement quadratically constrained quadratic problems (faster setup), then add many test
problems with known solutions.


#--------------------------------------------------------------
2017-01-14A:|
--------------

The class ConstraintSet also needs a method doSOIAnalysis which takes a set of
equality constraints, low priority. We need some tests for SOI feasibility analysis.

Simplify the various forms of the BarrierSolver.apply constructors by adding an optional feasible
point to the ConstraintSets and a method to add a feasible point.
The barrier solvers should now no longer assume that a feasible point is given. Instead check if
the inequality constraint set has one and if it is in the range of the equality constraints.
Otherwise it needs to perform a feasibility analysis to find one.
We need to beef up the simple feasibility analysis to be able to deal with equality constraints.

The simplest way may be to operate on the level of the objective function and inequality constraints
(by restricting these to the range of the equality constraints) and not on the level of the barrier solver.
However this is very inefficient since it implies many more matrix multiplications.

The matrices are bigger (more columns) the fewer equality conditions we have -- a bad constellation.

Consequently it might better to have two versions of simple feasibility analysis: one with
and one without equality constraints. The feasibility solver with equality constraints
needs separate implementation as only the variable x in the compound variable (x,s) is affected
by the transformation x=Fu.
Thus the matrix which transforms the barrier function has two blocks the second of which is the
identity matrix. Needless to say this multiplication can be implemented more efficiently by operating on
the blocks separately (and doing nothing on the block indexed by the s-variables).


#--------------------------------------------------------------
2017-01-23:|
--------------

Find out what the problem is with the accuracy of the solutions of the KKT system.
There is no problem with MatrixUtils.triangularSolve, the errors in the test cases
with the identical matrices H=LL' are zero.

Even though identical matrices L and  H=LL' are used in the test for MatrixUtils.triangularSolve
and the KKTSystem solution, the condition numbers are worse in the KKT case (1600 versus 500).
The equilibration of H in the KKTSystem solver seems to increase the condition number.
But it is still too small to cause such inaccuracy.
Thus there must be some other problem with the KKT code.

#--------------------------------------------------------------
2017-01-23:|
--------------

KKTSystem.solvePD:
when Ruiz equilibration is switched off (i.e. unmodified blockSolve is used) works
flawlessly with condition numbers of H as large as 2e6.
Ruiz equilibration cuts the condition numbers in half but then the accuracy of the
solution goes down badly.
There must therefore be a BUG in the transformation to and from the equilibrated system.

BUG is fixed, status: working!
